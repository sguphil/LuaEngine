Effective C++

1.习惯C++
	为了理解C++，必须认识其主要的次语言：
	1）C
	2）Object-Oriented C++
	3) Template C++
	4) STL

2.尽量以const, enum, inline替换#define
	宏定义在编译器处理源码前就被宏处理器处理移走了，因此宏定义符号并没有进入记号表（symbol table）。
	这里可以使用const定义常量来替换宏定义，const定义的常量必然进入符合表并被编译器处理。同时，程序运行时报错将获得明确的信息。
	特殊情况：
	在定义常量指针时有必要将指针声明为const并放中头文件中，如
		const char* const str = "string string";
	
	第二种情况是中类中专属常量，为了将常量的作用域限制于class内，就必须让它成为类的成员，而为了确保常量至多只有一份则必须把它声明为一个static成员。

	类中的static成员变量只是一个声明而非定义（定义意味着分配内存），编译器需要明确的变量定义，所以必须中类外进行变量定义。（有一种特殊情况是，如果static成员变量时整数类型（ints，chars， bools）且不去这个变量地址，且编译器没有硬性要求一个明确定义则可以只中类中声明就可以使用了）。

	使用#define实现宏时会出现误用情况，如：
	#define MAX(a, b) f((a)>(b) ? (a):(b)) -->调用f函数
	这里必须注意宏中所有实参都序言加上小括号，否则会出现运算顺序等问题，但是就算加上了小括号依然会出现问题，例如下面用法：
	int a = 5; 
	int b = 0;
	MAX(++a, b); //a被累加了两次
	MAX(++a, b+10); //a 累加了一次	

	为此我们可以使用模板基数解决这个问题，如下：
	template<typename T>
	inline void max(const T& a, const T& b)
	{
		f(a>b ? a : b);
	}


	这个函数将会缠上一群函数，每个函数接受不同的类系的对象。
	当然我们可以使用该技术轻松的实现一个类内的模板inline函数。

记住：
	对于单纯常量，最好用cosnt对象或者enum替换#define
	对于形似函数的宏，最好改用inline函数替换#define


3.尽可能使用const
	const可以告诉编译器和其他程序员某个值保持不变，只要这是一个事实就应该显式写明。	
	const最具威力的用法时面对函数声明时应用，中一个函数声明内，const科研和函数返回值，参数，函数自身（如果时成员函数）产生关联。
	const用于成员函数的目的时为了确认该成员函数可用于const对象，这类成员函数重要的原因是：1.使得class接口比较容易理解，因为得知那个函数可以改动对象内容那个不行时很重要的。 2.使得操作const对象成为可能。如下：
	TextBlock tb("Hello");
	std::cout << tb[0]; -->调用non-const TextBlock::operator[]
	
	const TextBlock ctb("world");
	std::cout << ctb[0] -->调用const TextBlock::operator[]

	在类中mutable修饰的成员变量可以中const成员函数中被修改，这增加了const函数的灵活性。

记住：
	将某些东西声明为const科研帮助编译器侦测出错误的用法。cosnt可以施加于任何作用域内的对象、函数参数、函数返回类型、成员函数。
	编译器强制实施bitwise constness，但你编写程序时应该使用“概念上的常量性”（conceptual constness）。
	当const和non-const成员函数有实质等价实现时，另non-const版本调用const版本可避免代码重复。

4.确定对象被使用前已被初始化
	在用户自定义类型中，如果不在构造函数初始化列表中初始化，而中函数体中初始化变量将会先调用这些变量的默认构造函数，因此在效率上不如中构造函数的初始化列表中初始化成员变量。但如果一个类中包含多个构造函数，每个函数都写出初始化列表将出现代码重复，这种情况下可以定义一个初始化函数供所有构造函数调用，但是效率上比不上初始化列表。

	C++有着十分固定的“成员初始化次序”，base classes先于derived classes被初始化，而class的成员变量总是以其声明次序被初始化（即使中成员初始化列表中出现的次序不同，仍然以其声明次序初始化，通常编译器会给出一个警告）。因此，成员初始化列表中的顺序最好和成员声明次序一致。
	static对象的寿命时从被构造出来直到程序结束，因此stack和heap-based对象都被排除。这种对象包括global对象、定义于namespace作用域内的对象、中classes内、中函数内、以及中file作用域内声明为static对象。函数内的static对象称为local static对象，其他对象称为non-local static对象。程序结束时对象会被自动销毁，也就是析构函数会中main()函数结束时自动调用。
	编译单元：指产出单一目标文件的那些源码，基本上它是单一文件加上其所包含的头文件。

	C++对“定义中不同编译单元内的non-local static对象”的初始化次序并无明确定义。

	将一个non-local static变量放到一个函数内定义为函数的local static对可以实现中第一次调用这个函数遇到这个定义时进行初始化。使用一个函数封装一个non-local static变量的产生将保证这个变量中使用时必然被初始化，该项技术也使用中单例模式中。如：
	T a; --> global non-local static 
	---->>change in this way
	T& instance()
	{
		static T a; -->local static init only once!!!
		return a;
	}

	但必须注意任何一种non-const static对象，不论它时local或non-local，在多线程环境下“等待某事发生”都会有麻烦，处理这个麻烦的一种做法是中程序的单线程启动阶段手工调用所有这种reference-returning函数，科研消除初始化有关的“竞速形势”（race condictions)。

记住：
	为内置型对象进行手工初始化，因为C++不保证初始化它们。
	构造函数最好使用成员初始化列表，不要在构造函数体内使用赋值操作。初始化列出的成员变量，其排列次序应该和它们中class中的声明次序相同。
	为免除“跨编译单元之初始化次序”问题，请以local static对象替换non-local static 对象。


5.了解C++默默编写并调用哪些函数
	C++编译器版本会在用户没有定义 copy构造函数、复制操作符函数、构造函数、析构函数 这四大函数时各自生成一个默认函数，所有这些函数都是public且inline。
	如：
	class empty{};
	编译器将会帮你把类定义成这样：
	class empyt	
	{
		empty(){...}
		empty(const empty& ins){...}
		~empty(){...}
		empty& operator=(const empty& ins){...}
	};

	这些函数唯有中被需要的时候才会被编译器创建出来。

	如果要禁止客户程序使用复制、构造、赋值操作可以将这些函数声明为类的private成员函数，在声明这些函数时如果参数并没有起到作用可以只写参数的类型不需要写明参数名,并且无需定义这些函数,这样做的好处是：当客户程序调用这些操作时，编译器将报错，当类内成员函数调用这些操作时，连接器将报错，因为这些成员函数只有声明。

	为了防止客户调用一个类的复制和赋值操作，好的办法时建立一个基类专门用于阻止这些行为。如:
	class Uncopyable
	{
		protected:
			Uncopyable();
			~Uncopyable();
		private:
			Uncopyable(const Uncopyable& );
			Uncopyable& operator=(const Uncopyable&); 
	}

	有了以上的类，在需要禁止这些操作的时候，就继承它，可以去除重复声明的麻烦。这个类可以把成员函数调用这些操作时连接器报错提前到编译器报错，因为在成员函数调用这些操作时，编译器会尝试生成一个这样的函数，而基类中也需要生成对于的版本，但中发现基类中已经声明这些函数，因此无法生成对应的操作函数，导致报错。但是这项技术可能会导致多重继承的问题因为这个基类没有数据时一个empty base class optimization,而多重继承有时会阻止empty base class optimization。

记住：
	为驳回编译器自动提供的机能，可将相应的函数声明为private并且不予实现。使用像Uncopyable这样的基类也时一种做法。


	

7.为多态基类声明virtual析构函数
	C++明确指出，当derived class对象经由一个base class指针被删除，而该base class带有一个non-virtual析构函数，其记过未有定义！！！实际执行时通常发生的时对象的derived成分没有被销毁。
	当对一个含有non-virtual的base class指针，并且指针指向一个子类进行销毁的时候，由于是基类指针，所有基类部分通常时会被正常销毁的，但是子类的析构函数没能执行起来，这就造成了局部销毁，形成资源泄漏、破坏数据结构等问题。
	因此要在基类中定义一个virtual析构函数，这样在销毁指向子类的基类指针的时候会删除整个类,因为virtual函数的目的时允许derived class实现得以客化(子类拥有自己的版本并可以通过父类指针进行调用)。
	如果一个class不含virtual函数，通常表示它并不意图被用作一个base class。当不被企图使用作base class，另其析构函数为virtual时一个坏主意，因为有virtual就必须引入vptr指向一个虚函数表，这将改变类的原来结构，在非继承类中这样做将带来不必要的麻烦。关于virtal的使用心得是：只有当class中含有至少一个virtual函数才把析构函数声明为virtual。

	由于stl的容器类及string类等没有virtual析构函数，因此如果继承它们中销毁一个指向子类的父类指针将导致未定义行为，因此对待stl的时候不能继承而是采用组合。
	析构函数的运作方式是，最深层派生的那个eclass其析构函数最先被调用，然后时其每一个base class的析构函数被调用。对于一个virtual析构函数，将先调用其子类的系够函数并且生成一个基类析构函数的调用，从而实现了整个类的完整销毁。

记住：
	polymorphic(多态性质的）base classes 应该声明一个virtual析构函数。如果class带有任何virtual函数，就应该拥有一个virtual析构函数。

	Classes的设计目的如果不是作为base classes使用，或不是为了具备多态性，就不应该声明virtual析构函数。


8.别让异常逃离析构函数
	C++并不仅值析构函数抛出异常，但是它不鼓励你这样做。
记住：
	析构函数绝对不要突出异常。如果一个被析构函数的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。
	如果客户需要对某个操作函数运行期间抛出的异常作出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。

9.绝不在构造和析构过程中调用virutal函数
	因为base class构造函数的执行更早于derived class构造函数，当base class构造函数执行时derived class的成员变量尚未初始化。更根本的原因是中derived class对象的base class构造期间，对象的类型时base class而不是derived class。不仅virtual函数会被编译器解析至（resolve to）base class,若使用运行时类型信息（如dynamic_cast和typeid）,也会把对象视为base class类型。

记住：
	在构造函数和析构期间不要调用virtual函数，因为这类调用从不降至derived class（对当前执行构造和析构函数那层而言）。	

10.令operator=返回一个reference to *this
	为了实现“连续赋值”，赋值操作符必须返回一个reference指向复制操作符左侧实参。这是实现赋值操作符应该遵循。
	class widget
	{
		public:
			...
		widget& operator=(const widget& rhs)
		{
			...
			return *this; //返回左值
		}
	};

	对于其他赋值相关运算同样需要遵循以上规则，如：+=，×=，-=等等

记住：
	令赋值操作符返回一个reference to *this。

11.在operator=中处理“自我赋值”
	
记住：
	确保当对象自我赋值时operator=有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序，以及copy-and-swap。
	确定任何函数如果操作一个以上的对象，而其中多个对象时同一个对象时，其中为仍然正确。

12.复制对象时勿忘其每一个成分
	在实现赋值操作符和复制构造函数的时候必须对类中的每一个成员变量进行处理，如果时一个子类，必须先调用父类的拷贝构造函数，否则会出现只复制了子类成员而父类成员未处理的问题，而且这中问题编译器并不会提示警告或者错误。

	当编写一个copying函数必须确保（1）复制所有local成员变量，（2）调用base classes内的适当的copying函数。

	例如：
	class base
	{
		public:
			...
			base(const base& rhs);
			base& operator=(const base& rhs);
		private:
			std::string m_a;
	};


	class derived:public base
	{
		public:
			derived(const derived& rhs);
			derived& operator=(const derived& rhs);
		private:
			std::string m_str;
	};

	========>>impl
	derived::derived(const derived& rhs)
		:base(rhs), ------>> 调用父类拷贝构造函数
		 m_str(rhs.m_str)
	{
		printf("derived copy ctor");	
	};

	derived& derived::operator=(const derived& rhs)
	{
		printf("derived operator= ");
		base::operator=(rhs); -->>调用父类的赋值函数
		m_str = rhs.m_str;
		return *this;
	};


	注意赋值构造函数内调用的对应的也时父类的赋值函数而不是复制构造函数，因为复制构造函数意味着构造一个已存在的对象。因此特别注意：不该在copy assignment操作符调用copy构造函数。同样，也不应该在copy构造函数调用copy assignment操作符。

	如果发现copy构造函数和copy assignment函数有重复的代码，解决这个的办法是建立一个新的成员函数供两者调用。

记住：
	copying函数应该确保复制“对象内的所有成员变量”及“所有base class成分”。
	不要尝试以某个copying函数实现另一个copying函数，应该将共同的代码放到一个新的函数中让两个copying函数共同调用。

13. 以对象管理资源
	（1）获得资源后立刻放进管理对象内。例如获得一个资源的时候马上用来初始化auto_prt。实际上“以对象管理资源”的观念常被成为“资源取得时机便是初始化时机”（Resource Acquisition Is Initialization; RAII).
	（2）管理对象运用析构函数确保资源被释放。

	由于auto_ptr被销毁的时候自动删除它所指向的对象，因此不能让多个auto_ptr指向同一个对象，否则会出现资源被多次释放的未定义行为。因此，auto_ptr有一个特性：如果通过copy构造函数或copy assignment操作符复制它们，它们会变成NULL, 而复制所得的指针将取得资源的唯一拥有权。

	但是auto_ptr的这些非正常复制行为也使得它并非管理动态分配资源的神兵利器。其替代方案是“引用计数智慧型指针”(reference-counting smart pointer; RCSP).TR1的tr1::shared_ptr就是RCSP,其复制函数则是正常行为。
	由于auto_ptr和tr1::share_ptr的析构函数做的都是delete而不是delete[]操作，因此不能用它们来管理动态分配的array。
	
记住：
	为了防止资源泄漏，请使用RAII对象，它们中构造函数中获得资源并在析构函数中释放资源。
	两个常被使用的RAII classes分别是tr1::share_ptr和auto_prt。前者通常时较好的选择，因为它的copy行为比较直观。若选择auto_prt，复制动作会使它（被复制物）指向NULL。


14. 在资源管理类中小心coping行为
	由于使用RAII技术，我们可能需要建立自己的资源管理类，如互斥锁Mutex;但是在定义自己的RAII类时，需要注意coping行为，对于复制行为通常有以下做法：
	（1）禁止复制，将copying操作声明为private。
	（2）对底层资源使用“引用计数法“。
	（3）复制底部资源。
	（4）转移底部资源的拥有权。做法如auto_ptr那样。
	copying函数有可能被编译器自动创建出来，因此除非编译器所产生的版本做了你想要做的事，否则你要自己编写它们。

记住：
	复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定了RAII对象的copying行为。
	普遍而常见的RAII class copying 行为是：抑制copying、施行引用计数法。不过其他行为也可能被实现。


15.在资源管理类中提供对原始资源的访问
		
